# OKOKOKOKOKOKOKOKOKOKOKOK

#一个很简单的Makefile模板  

CC=gcc
#########################################################
# 递归展开式变量:
# 缺点1：使用此风格的变量定义，可能会由于出现变量递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败.
# 缺点2：这种风格的变量定义中如果使用了函数，那么包含在变量值中的函数总会在变量被引用的地方执行（变量被展开时）
#########################################################
SRCDIRS = . sub1 sub2
INCLDIRS = h
SRCS=$(foreach dir,$(SRCDIRS),$(wildcard $(dir)/*.c))
INCL=$(addprefix -I,$(INCLDIRS))
TARGET = main

OBJ := $(SRCS:.c=.o)
#########################################################
# 直接展开式变量
# 在使用“:=”定义变量时，变量值中对其他变量或者函数的引用在定义变量时被展开（对变量进行替换）

# 变量的替换引用,格式为“$(VAR:A=B)”（或者“${VAR:A=B}”），意思是，替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。
# “结尾”的含义是空格之前（变量值多个字之间使用空格分开）而对于变量其它部分的“A”字符不进行替换。
#########################################################


all:$(OBJ)
	$(CC) $(INCL) -DDEBUG -Wall -g -o $(TARGET) $(OBJ)
#########################################################
# 第一个规则，作为终极目标.“终极目标”就是当没有使用make 命令行指定具体目标时，make默认的更新的那一个目标。
#########################################################


%.o:%.c
	$(CC) $(INCL) -DDEBUG -Wall -g -o $@ -c $<
#########################################################
#在模式规则中，目标文件是一个带有模式字符“%”的文件，使用模式来匹配目标文件。文件名中的模式字符“%”
#可以匹配任何非空字符串，除模式字符以外的部分要求一致。

#在目标文件名中“%”匹配的部分称为“茎”。使用模式规则时，目标文件匹配之后得到“茎”，依赖根据“茎”产生对应的
#依赖文件，这个依赖文件必须是存在的或者可被创建的。

#此规则描述了一个.o文件如何由对应的.c文件创建。规则的命令行中使用了自动化变量“$<”和“$@”，其中，
#自动化变量“$<”代表规则的依赖“$@”代表规则的目标。此规则在执行时，命令行中的自动化变量将根据实际
#的目标和依赖文件取对应值。
#########################################################

.PHONY:clean
#########################################################
# 伪目标是这样一个目标：它不代表一个真正的文件名，在执行make
# 时可以指定这个目标来执行其所在规则定义的命令，有时也可以将
# 一个伪目标称为标签。
# 使用伪目标有两点原因：1. 避免在我们的Makefile中定义的只执行命
# 令的目标（此目标的目的为了执行执行一些列命令，而不需要创建
# 这个目标）和工作目录下的实际文件出现名字冲突。2. 提高执行make
# 时的效率。
#########################################################

clean:
	-rm -f $(OBJ)
